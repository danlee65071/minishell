# minishell
Цель этого проекта - создать простую оболочку.
## Описание разрешенных функций

### char \*readline(const char \*prompt)
readline читает строку из терминала и вернет ее, используя prompt в качестве подсказки. Если prompt является NULL или пустой строкой, подсказка не выводится. Возвращенная строка выделяется с помощью malloc, вызывающий должен освободить его по завершении. В возвращаемой строке окончательный символ новой строки удален, поэтому остается только текст строки.

### void rl_clear_history(void)
Очищает список истории, удалив все записи, таким же образом, как функция clear_history () библиотеки истории. Это отличается от clear_history тем, что освобождает личные данные, которые readline сохраняет в списке истории.

### int rl_on_new_line(void)
Сообщает функциям обновления, что мы переместились на новую (пустую) строку, обычно после вывода новой строки.

### void rl_replace_line(const char \*text, int clear_undo)
Заменяет содержимое rl_line_buffer текстом text. По возможности точка и отметка сохраняются. Если clear_undo отличен от нуля, список отмены, связанный с текущей строкой, очищается.  
**Переменная char \*rl_line_buffer** - это строка, в которой содержится вся предыдущая информация, собранная до сих пор.  
**Переменная int rl_point** - смещение текущей позиции курсора в rl_line_buffer (точка).  
**Переменная int rl_mark** - метка (сохраненная позиция) в текущей строке.  

### void rl_redisplay(void)
Отображает на экране содержимое переменной rl_line_buffer.  
### void add_history (const char \*string) 
Помещает строку в конец списка истории. Связанное поле данных (если есть) установлено в NULL.   

### int printf(const char \*format, ...)
Выводит данные в соответствии с параметром format. При успешном завершении работы эти функции возвращают количество напечатанных символов (не включая завершающий '\0', использующийся для обозначения конца строки данных). Если случилась ошибка вывода, то возвратится отрицательное значение. 

### void \*malloc(size_t sizemem)
Выделяет блок памяти, размером sizemem байт, и возвращает указатель на начало блока. Содержание выделенного блока памяти не инициализируется, оно остается с неопределенными значениями. Указатель на выделенный блок памяти. Тип данных на который ссылается указатель всегда void \*, поэтому это тип данных может быть приведен к желаемому типу данных. Если функции не удалось выделить требуемый блок памяти, возвращается нулевой указатель.

### void free( void \*ptrmem)
Функция free освобождает место в памяти. Блок памяти, ранее выделенный с помощью вызова malloc, calloc или realloc освобождается. Обратите внимание, что эта функция оставляет значение ptr неизменным, следовательно, он по-прежнему указывает на тот же блок памяти, а не на нулевой указатель.

### int open(const char \*FILENAME, int FLAGS, mode_t MODE) или int open (const char \*FILENAME, int FLAGS)
Устанавливает путь к файлу или устройству. Вызов open возвращает новый дескриптор файла (всегда неотрицательное целое) в случае успешного завершения или -1 в случае неудачи. Имя открываемого файла или устройства передается как параметр FILENAME, параметр FLAGS применяется для указания действий, предпринимаемых при открытии файла, а параметр MODE определяет режим файла (по сути права доступа). Двойственность прототипа достигается благодаря механизму va_arg.


The objective of this project is for you to create a simple shell.
